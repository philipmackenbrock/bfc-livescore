<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live Ranking</title>
  <style>
    :root{
      --bg:#f7fafc;
      --card:#fff;
      --muted:#6b7280;
      --accent:#0f172a;
      --accent-2:#374151;
      --good: rgba(34,197,94,0.12);
      --bad:  rgba(239,68,68,0.10);
    }
    html,body{height:100%}
    body {
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:var(--bg);
      color:var(--accent);
      margin:0;
      padding:28px;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .container { max-width:1100px; margin:0 auto; }
    .leaderboard {
      background:var(--card);
      border-radius:12px;
      padding:18px;
      box-shadow:0 6px 20px rgba(2,6,23,0.06);
      overflow:hidden;
    }
    header.top {
      display:flex;
      align-items:baseline;
      gap:16px;
      margin-bottom:12px;
    }
    h1 { margin:0; font-size:1.25rem; font-weight:600; color:var(--accent-2) }
    .meta { color:var(--muted); font-size:0.9rem }
    #error { color:#b91c1c; margin-top:8px; font-size:0.95rem; display:none }
    table {
      width:100%;
      border-collapse:collapse;
      table-layout:fixed;
      font-size:0.95rem;
    }
    thead th {
      text-align:left;
      padding:12px 10px;
      font-weight:700;
      color:var(--muted);
      border-bottom:1px solid #eef2f6;
    }
    tbody td {
      padding:10px;
      border-bottom:1px solid #f3f6f9;
      vertical-align:middle;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .pos { width:56px; text-align:center; font-weight:700; }
    .competitor { min-width:160px; font-weight:600; color:var(--accent-2) }
    .value { text-align:center; }
    .score { text-align:right; font-weight:700; width:110px; }
    tbody tr { background:transparent; will-change: transform, opacity; transition: box-shadow .35s ease; }
    tbody tr.rank-up { box-shadow: inset 6px 0 0 var(--good); }
    tbody tr.rank-down { box-shadow: inset 6px 0 0 var(--bad); }
    tbody tr.top1 { background: linear-gradient(90deg, rgba(255,215,0,0.06), transparent); }
    tbody tr.top2 { background: linear-gradient(90deg, rgba(192,192,192,0.05), transparent); }
    tbody tr.top3 { background: linear-gradient(90deg, rgba(205,127,50,0.05), transparent); }
    @media (max-width:820px){
      .competitor { min-width:120px; }
      .score { width:80px; }
      thead th, tbody td { padding:8px; font-size:0.88rem; }
      .pos { width:44px; }
    }
    /* helper small text */
    .note { margin-top:8px; font-size:0.88rem; color:var(--muted) }
  </style>
</head>
<body>
  <div class="container">
    <div class="leaderboard" aria-live="polite">
      <header class="top">
        <h1>Live Ranking</h1>
        <div class="meta" id="lastUpdated">—</div>
      </header>

      <div id="error" role="alert"></div>

      <table id="board" role="table" aria-label="Live ranking table">
        <thead><tr id="headerRow"></tr></thead>
        <tbody></tbody>
      </table>

      <div class="note">Datenquelle: Google Sheets (Live). Aktualisiert automatisch.</div>
    </div>
  </div>

<script>
/* ====== CONFIG (keep as provided) ====== */
const SHEET_ID = "1H7pI6CWOnP6QedIxfdFLRO_8DkswdLTc7v5rSu0TvNA";
const API_KEY  = "AIzaSyBGFkhdQZ3le5u_dI-fsmDMoD1VMPkQXEE";
const RANGE    = "Live!B1:K100"; // B=Name, C-J values, K Total
const POLL_MS  = 8000;           // refresh every 8s
/* ====================================== */

const URL = `https://sheets.googleapis.com/v4/spreadsheets/${encodeURIComponent(SHEET_ID)}/values/${encodeURIComponent(RANGE)}?key=${encodeURIComponent(API_KEY)}`;

const tbody = document.querySelector('#board tbody');
const headerRow = document.getElementById('headerRow');
const lastUpdatedEl = document.getElementById('lastUpdated');
const errorEl = document.getElementById('error');

let rowElements = new Map(); // id -> tr
let previousOrder = [];
let previousRanks = {};

// sanitize text
function text(node, str){
  if(node) node.textContent = (str === undefined || str === null) ? '' : String(str);
}

// create a TR element for a row (data array: [Name, val1..val8, Total] indexes 0..9)
function createRow(id, dataArray){
  const tr = document.createElement('tr');
  tr.dataset.id = id;

  // position cell
  const tdPos = document.createElement('td');
  tdPos.className = 'pos';
  tdPos.setAttribute('aria-label','Position');
  tdPos.textContent = '';
  tr.appendChild(tdPos);

  // name
  const tdName = document.createElement('td');
  tdName.className = 'competitor';
  tdName.setAttribute('aria-label','Competitor');
  text(tdName, dataArray[0] || '');
  tr.appendChild(tdName);

  // values C-J -> indices 1..8
  for(let i=1;i<=8;i++){
    const td = document.createElement('td');
    td.className = 'value';
    td.setAttribute('aria-label',`Value ${i}`);
    text(td, dataArray[i] || '');
    tr.appendChild(td);
  }

  // total (index 9)
  const tdTotal = document.createElement('td');
  tdTotal.className = 'score';
  tdTotal.setAttribute('aria-label','Total');
  text(tdTotal, dataArray[9] || '');
  tr.appendChild(tdTotal);

  return tr;
}

// update existing tr with new data
function updateRow(tr, dataArray){
  if(!tr) return;
  const cells = tr.children;
  // cells[0] = pos, [1] = name, [2..9] values, last = total
  text(cells[1], dataArray[0] || '');
  for(let i=1;i<=8;i++){
    const idx = 1 + i; // cell index
    if(cells[idx]) text(cells[idx], dataArray[i] || '');
  }
  // total is last cell
  const totalCell = cells[cells.length - 1];
  if(totalCell) text(totalCell, dataArray[9] || '');
}

// FLIP-based render with smooth slide animation
function renderFlip(header, rows){
  if(!header || header.length === 0) return;

  // Build header row (B1..K1) -> header[0] is "Name", header[1..8] categories, header[9] "Total"
  headerRow.innerHTML = ''; // rebuild safely
  const thPos = document.createElement('th'); thPos.className='pos'; thPos.textContent='#'; headerRow.appendChild(thPos);
  const thName = document.createElement('th'); thName.className='competitor'; thName.textContent = header[0] || 'Name'; headerRow.appendChild(thName);
  for(let i=1;i<=8;i++){
    const th = document.createElement('th');
    th.className = 'value';
    th.textContent = header[i] || '';
    headerRow.appendChild(th);
  }
  const thTotal = document.createElement('th'); thTotal.className='score'; thTotal.textContent = header[9] || 'Total'; headerRow.appendChild(thTotal);

  // sort rows descending by total (index 9)
  rows.sort((a,b)=> Number((b[9]||0)) - Number((a[9]||0)));

  // newOrder (IDs)
  const newOrder = rows.map((r, i) => {
    // id from name (must be stable); fallback to index-based unique id
    const name = (r[0]||'').toString().trim();
    return name.length ? name : `__row_${i}`;
  });

  const rowsById = {};
  rows.forEach((r,i)=> rowsById[newOrder[i]] = r);

  // removals: elements in previousOrder not in newOrder
  const removed = previousOrder.filter(id => !newOrder.includes(id));
  removed.forEach(id => {
    const tr = rowElements.get(id);
    if(!tr) return;
    tr.style.transition = 'transform 300ms ease, opacity 300ms ease, height 300ms ease';
    tr.style.transform = 'translateY(-8px)';
    tr.style.opacity = '0';
    setTimeout(()=> {
      if(tr.parentElement) tr.parentElement.removeChild(tr);
      rowElements.delete(id);
    }, 320);
  });

  // measure start positions
  const firstRects = new Map();
  rowElements.forEach((el,id) => firstRects.set(id, el.getBoundingClientRect()));

  // append/create nodes in new order
  newOrder.forEach((id, idx) => {
    const data = rowsById[id] || [];
    if(rowElements.has(id)){
      const el = rowElements.get(id);
      updateRow(el, data);
      tbody.appendChild(el); // moves el to new position
    } else {
      const el = createRow(id, data);
      // start invisible for entry animation
      el.style.opacity = '0';
      el.style.transform = 'translateY(-8px)';
      tbody.appendChild(el);
      rowElements.set(id, el);
    }
  });

  // measure last positions
  const lastRects = new Map();
  rowElements.forEach((el,id) => lastRects.set(id, el.getBoundingClientRect()));

  // FLIP animate
  rowElements.forEach((el, id) => {
    const first = firstRects.get(id);
    const last = lastRects.get(id);
    el.style.transition = 'none';
    if(first){
      const deltaY = first.top - last.top;
      if(Math.abs(deltaY) > 0.5){
        el.style.transform = `translateY(${deltaY}px)`;
        el.style.opacity = '1';
        requestAnimationFrame(()=> {
          el.style.transition = 'transform 600ms cubic-bezier(.2,.8,.2,1)';
          el.style.transform = 'translateY(0)';
        });
      } else {
        el.style.transform = '';
        el.style.opacity = '1';
      }
    } else {
      // new element
      requestAnimationFrame(()=> {
        el.style.transition = 'transform 600ms cubic-bezier(.2,.8,.2,1), opacity 600ms';
        el.style.transform = 'translateY(0)';
        el.style.opacity = '1';
      });
    }
    // set pos cell after animation
    const posCell = el.querySelector('.pos');
    const newPos = newOrder.indexOf(id) + 1;
    if(posCell) posCell.textContent = newPos;

    // clear any previous classes then set top classes etc
    el.classList.remove('rank-up','rank-down','top1','top2','top3');
  });

  // compute rank changes and set highlight classes temporarily
  const newRanks = {};
  newOrder.forEach((id, idx) => newRanks[id] = idx+1);
  newOrder.forEach((id, idx) => {
    const pos = idx+1;
    const el = rowElements.get(id);
    if(!el) return;
    if(pos === 1) el.classList.add('top1');
    if(pos === 2) el.classList.add('top2');
    if(pos === 3) el.classList.add('top3');

    const old = previousRanks[id];
    if(old !== undefined && old !== pos){
      if(old > pos) {
        el.classList.add('rank-up');
        setTimeout(()=> el.classList.remove('rank-up'), 1200);
      } else {
        el.classList.add('rank-down');
        setTimeout(()=> el.classList.remove('rank-down'), 1200);
      }
    }
  });

  previousOrder = newOrder.slice();
  previousRanks = Object.assign({}, newRanks);
}

// fetch from Sheets
async function fetchValues(){
  const res = await fetch(URL, {cache:'no-store'});
  if(!res.ok){
    // better error message for user
    const text = await res.text().catch(()=> '');
    throw new Error(`${res.status} ${res.statusText} ${text}`);
  }
  const json = await res.json();
  return json.values || [];
}

// update last updated timestamp (Europe/Berlin)
function setLastUpdated(){
  try {
    const now = new Date();
    const s = now.toLocaleString('de-DE', { timeZone: 'Europe/Berlin', hour12:false });
    lastUpdatedEl.textContent = `Letzte Aktualisierung: ${s}`;
  } catch(e){
    lastUpdatedEl.textContent = `Letzte Aktualisierung: ${new Date().toISOString()}`;
  }
}

// main refresh
let isRefreshing = false;
async function refresh(){
  if(isRefreshing) return;
  isRefreshing = true;
  errorEl.style.display = 'none';
  try{
    const values = await fetchValues(); // returns array of rows (B1..K)
    if(!values || values.length <= 1){
      throw new Error('Keine Daten in Live sheet gefunden.');
    }
    const header = values[0];
    const rows = values.slice(1); // each row: [Name, v1..v8, total]
    renderFlip(header, rows);
    setLastUpdated();
  } catch(err){
    console.error('Fetch error', err);
    errorEl.style.display = 'block';
    errorEl.textContent = 'Fehler beim Laden der Live-Daten. Bitte Seite neu laden oder später versuchen.';
  } finally {
    isRefreshing = false;
  }
}

// initial load + polling
refresh();
setInterval(refresh, POLL_MS);
</script>
</body>
</html>
